from flask import Flask, render_template, request, redirect, url_for, flash, make_response, jsonify, abort, session
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user
from flask_bcrypt import Bcrypt
import os
from datetime import datetime, timedelta
from slugify import slugify
import uuid # Para gerar nomes de arquivo únicos
from werkzeug.utils import secure_filename # Para uploads seguros
from models import db, User, News, Comment, Category, Tag # Importar os modelos
from PIL import Image, ExifTags # Importar Pillow e ExifTags
import random
import json
from sqlalchemy import func
import subprocess
import shlex
import threading
import time

app = Flask(__name__, instance_path=os.path.abspath(os.path.join(os.path.dirname(__file__), 'instance')))
app.config['SECRET_KEY'] = 'uma_chave_secreta_muito_segura_e_longa_que_deve_ser_substituida_em_producao'
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(app.instance_path, 'site.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['UPLOAD_FOLDER_IMAGES'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static', 'uploads', 'images')
app.config['UPLOAD_FOLDER_VIDEOS'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static', 'uploads', 'videos')
app.config['UPLOAD_FOLDER_VIDEOS_PROCESSED'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static', 'uploads', 'videos', 'processed')
app.config['MAX_CONTENT_LENGTH'] = 300 * 1024 * 1024 # Limite de 300MB para uploads de imagens/vídeos

# Criar diretórios de upload se não existirem
os.makedirs(app.config['UPLOAD_FOLDER_IMAGES'], exist_ok=True)
os.makedirs(app.config['UPLOAD_FOLDER_VIDEOS'], exist_ok=True)
os.makedirs(app.config['UPLOAD_FOLDER_VIDEOS_PROCESSED'], exist_ok=True)

# Subpastas para imagens redimensionadas
os.makedirs(os.path.join(app.config['UPLOAD_FOLDER_IMAGES'], 'thumb'), exist_ok=True)
os.makedirs(os.path.join(app.config['UPLOAD_FOLDER_IMAGES'], 'medium'), exist_ok=True)
os.makedirs(os.path.join(app.config['UPLOAD_FOLDER_IMAGES'], 'original'), exist_ok=True)

db.init_app(app) # Inicializar o SQLAlchemy com o app
bcrypt = Bcrypt(app) # Inicializar o Flask-Bcrypt com o app
login_manager = LoginManager(app)
login_manager.login_view = 'login' # The view to redirect to when a user needs to log in.

ALLOWED_IMAGE_EXTENSIONS = {'png', 'jpg', 'jpeg', 'webp'}
ALLOWED_VIDEO_EXTENSIONS = {'mp4', 'mov', 'avi', 'webm'}

def allowed_file(filename, allowed_extensions):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in allowed_extensions

def save_and_resize_image(image_file):
    if image_file and allowed_file(image_file.filename, ALLOWED_IMAGE_EXTENSIONS):
        # Gerar nome único para o arquivo
        filename = str(uuid.uuid4()) + '.' + image_file.filename.rsplit('.', 1)[1].lower()
        original_path = os.path.join(app.config['UPLOAD_FOLDER_IMAGES'], 'original', filename)
        thumb_path = os.path.join(app.config['UPLOAD_FOLDER_IMAGES'], 'thumb', filename)
        medium_path = os.path.join(app.config['UPLOAD_FOLDER_IMAGES'], 'medium', filename)

        # Salvar a imagem original
        image_file.save(original_path)

        # Abrir a imagem com PIL
        img = Image.open(original_path)

        # Corrigir orientação da imagem baseada em dados EXIF
        try:
            for orientation in ExifTags.TAGS.keys():
                if ExifTags.TAGS[orientation] == 'Orientation':
                    break
            
            exif = dict(img._getexif().items())
            
            if exif[orientation] == 3:
                img = img.rotate(180, expand=True)
            elif exif[orientation] == 6:
                img = img.rotate(270, expand=True)
            elif exif[orientation] == 8:
                img = img.rotate(90, expand=True)
        except (AttributeError, KeyError, IndexError):
            # Imagem não tem dados EXIF ou não tem orientação
            pass

        # Padronizar para formato 16:9 (largura fixa, altura proporcional)
        # Thumbnail (300px de largura)
        thumb_width = 300
        thumb_height = int(thumb_width * 9/16)  # Altura proporcional para 16:9
        
        # Criar uma nova imagem com fundo preto para o thumbnail
        thumb_img = Image.new('RGB', (thumb_width, thumb_height), (0, 0, 0))
        
        # Redimensionar a imagem original mantendo a proporção
        img_thumb = img.copy()
        img_thumb.thumbnail((thumb_width, thumb_height))
        
        # Calcular a posição para centralizar a imagem redimensionada
        thumb_pos_x = (thumb_width - img_thumb.width) // 2
        thumb_pos_y = (thumb_height - img_thumb.height) // 2
        
        # Colar a imagem redimensionada na nova imagem
        thumb_img.paste(img_thumb, (thumb_pos_x, thumb_pos_y))
        thumb_img.save(thumb_path)
        
        # Medium (600px de largura)
        medium_width = 600
        medium_height = int(medium_width * 9/16)  # Altura proporcional para 16:9
        
        # Criar uma nova imagem com fundo preto para o medium
        medium_img = Image.new('RGB', (medium_width, medium_height), (0, 0, 0))
        
        # Redimensionar a imagem original mantendo a proporção
        img_medium = img.copy()
        img_medium.thumbnail((medium_width, medium_height))
        
        # Calcular a posição para centralizar a imagem redimensionada
        medium_pos_x = (medium_width - img_medium.width) // 2
        medium_pos_y = (medium_height - img_medium.height) // 2
        
        # Colar a imagem redimensionada na nova imagem
        medium_img.paste(img_medium, (medium_pos_x, medium_pos_y))
        medium_img.save(medium_path)

        return filename
    return None

def process_video(video_file):
    """
    Processa um vídeo para criar uma versão otimizada.
    Retorna o nome do arquivo processado ou None se falhar.
    """
    if video_file and allowed_file(video_file.filename, ALLOWED_VIDEO_EXTENSIONS):
        # Gerar nome único para o arquivo
        original_filename = str(uuid.uuid4()) + '.' + video_file.filename.rsplit('.', 1)[1].lower()
        processed_filename = original_filename.rsplit('.', 1)[0] + '.mp4'
        
        original_path = os.path.join(app.config['UPLOAD_FOLDER_VIDEOS'], original_filename)
        processed_path = os.path.join(app.config['UPLOAD_FOLDER_VIDEOS_PROCESSED'], processed_filename)
        
        # Salvar o vídeo original
        video_file.save(original_path)
        
        try:
            # Usar FFmpeg para processar o vídeo (redimensionar para 720p e otimizar)
            command = f'ffmpeg -i "{original_path}" -vf "scale=-1:720" -c:v libx264 -preset medium -crf 23 -c:a aac -b:a 128k "{processed_path}"'
            
            # Executar o comando
            try:
                result = subprocess.run(
                    shlex.split(command),
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    check=True
                )
                print(f"Vídeo processado com sucesso: {result.stdout}")
                
                # Remover o arquivo original após o processamento bem-sucedido
                os.remove(original_path)
                return processed_filename
                
            except subprocess.CalledProcessError as e:
                print(f"Erro ao processar vídeo: {e.stderr}")
                # Se falhar, manter o arquivo original
                return original_filename
                
        except Exception as e:
            print(f"Erro ao processar vídeo: {str(e)}")
            # Em caso de erro, retornar o nome do arquivo original
            return original_filename
            
    return None

@login_manager.user_loader
def load_user(user_id):
    return db.session.get(User, int(user_id))

# --- Database Models ---
# REMOVED: User and NewsArticle model definitions are now in backend/models.py

# --- Routes ---
@app.route('/')
def index():
    return "Bem-vindo ao site! Em breve, suas notícias aqui."

@app.route('/blog')
@app.route('/blog/categoria/<category_slug>')
@app.route('/blog/tag/<tag_slug>')
def blog(category_slug=None, tag_slug=None):
    page = request.args.get('page', 1, type=int)
    per_page = 10
    
    query = News.query.filter_by(status='published')
    
    category = None
    tag = None
    
    if category_slug:
        category = Category.query.filter_by(slug=category_slug).first_or_404()
        query = query.filter_by(category_id=category.id)
    
    if tag_slug:
        tag = Tag.query.filter_by(slug=tag_slug).first_or_404()
        query = query.filter(News.tags_rel.contains(tag))
    
    news_pagination = query.order_by(News.publication_date.desc()).paginate(page=page, per_page=per_page)
    
    # Obter categorias populares para o menu lateral
    popular_categories = Category.query.join(News, Category.id == News.category_id)\
                                .filter(News.status == 'published')\
                                .group_by(Category.id)\
                                .order_by(db.func.count(News.id).desc())\
                                .limit(10).all()
    
    # Obter tags populares para o menu lateral
    popular_tags = Tag.query.join(news_tags)\
                         .join(News, News.id == news_tags.c.news_id)\
                         .filter(News.status == 'published')\
                         .group_by(Tag.id)\
                         .order_by(db.func.count(News.id).desc())\
                         .limit(20).all()
    
    # Obter notícias em destaque
    featured_news = News.query.filter_by(status='published', is_featured=True)\
                         .order_by(News.publication_date.desc())\
                         .limit(5).all()
    
    return render_template('news/blog.html', 
                          news_pagination=news_pagination, 
                          category=category,
                          tag=tag,
                          popular_categories=popular_categories,
                          popular_tags=popular_tags,
                          featured_news=featured_news)

@app.route('/blog/<slug>')
def news_detail(slug):
    article = News.query.filter_by(slug=slug).first_or_404()
    
    # Converter a lista de imagens da galeria para JSON se existir
    gallery_images_json = None
    if article.gallery_images:
        gallery_images = article.gallery_images.split(',')
        gallery_images_json = json.dumps([url_for('static', filename=f'uploads/images/medium/{img}') for img in gallery_images])
    
    return render_template('news/news_detail.html', 
                          article=article, 
                          current_year=datetime.now().year,
                          gallery_images_json=gallery_images_json)

@app.route('/blog/<int:article_id>/comment', methods=['POST'])
def add_comment(article_id):
    article = News.query.get_or_404(article_id)
    author = request.form['author']
    email = request.form.get('email')
    content = request.form['content']

    if not author or not content:
        flash('Por favor, preencha todos os campos obrigatórios (Nome e Comentário).', 'danger')
        return redirect(url_for('news_detail', slug=article.slug))

    new_comment = Comment(news_article_id=article.id, author=author,
                            email=email, content=content, approved=False)
    db.session.add(new_comment)
    db.session.commit()
    flash('Seu comentário foi enviado e está aguardando aprovação.', 'success')
    return redirect(url_for('news_detail', slug=article.slug))

@app.route('/sitemap.xml')
def sitemap():
    articles = News.query.filter_by(status='publicada').order_by(News.publication_date.desc()).all()
    sitemap_content = render_template('sitemap.xml', articles=articles, current_date=datetime.utcnow())
    response = make_response(sitemap_content)
    response.headers['Content-Type'] = 'application/xml'
    return response

# Admin routes
@app.route('/admin')
@login_required
def admin_dashboard():
    # Estatísticas para o dashboard
    from datetime import datetime, timedelta
    import json
    
    # Data atual
    current_date = datetime.now()
    day_delta = timedelta(days=1)
    
    # Total de notícias
    total_news = News.query.count()
    
    # Comentários pendentes
    pending_comments = Comment.query.filter_by(approved=False).count()

    # Comentários recentes
    recent_comments = Comment.query.order_by(Comment.publication_date.desc()).limit(5).all()

    # Usuários
    total_users = User.query.filter_by(active=True).count()
    
    # Visualizações
    views_today = 100  # Placeholder - implementar tracking de visualizações
    views_trend = 5    # Placeholder - percentual de aumento/diminuição
    
    # Visualizações dos últimos 7 dias (placeholder)
    views_last_7_days = [45, 62, 78, 70, 85, 90, 100]
    
    # Formatar datas para o gráfico
    view_dates = []
    for i in range(6, -1, -1):
        date = (current_date - (day_delta * i)).strftime("%d/%m")
        view_dates.append(date)
    
    # Notícias por status
    news_by_status = {
        'published': News.query.filter_by(status='published').count(),
        'draft': News.query.filter_by(status='draft').count(),
        'scheduled': News.query.filter_by(status='scheduled').count()
    }
    
    # Notícias por categoria
    categories = Category.query.all()
    category_labels = []
    category_counts = []
    
    for category in categories:
        category_labels.append(category.name)
        category_counts.append(len(category.news_articles))
    
    # Limitar a 8 categorias para o gráfico
    if len(category_labels) > 8:
        category_labels = category_labels[:7] + ["Outras"]
        other_count = sum(category_counts[7:])
        category_counts = category_counts[:7] + [other_count]
    
    # Compilar todas as estatísticas em um único objeto
    stats = {
        'current_date': current_date,
        'total_news': total_news,
        'pending_comments': pending_comments,
        'recent_comments': recent_comments,
        'total_users': total_users,
        'views_today': views_today,
        'views_trend': views_trend,
        'views_last_7_days': json.dumps(views_last_7_days),
        'view_dates': json.dumps(view_dates),
        'news_by_status': news_by_status,
        'category_labels': json.dumps(category_labels),
        'category_counts': json.dumps(category_counts)
    }
    
    # Notícias recentes
    recent_news = News.query.order_by(News.publication_date.desc()).limit(5).all()
    
    return render_template('admin/dashboard.html', stats=stats, recent_news=recent_news)

@app.route('/admin/news')
@login_required
def news_list():
    if current_user.role not in ['admin', 'editor', 'redator']:
        flash('Permissão negada', 'danger')
        return redirect(url_for('admin_dashboard'))
    
    page = request.args.get('page', 1, type=int)
    per_page = 10
    
    # Filtros
    status_filter = request.args.get('status')
    category_filter = request.args.get('category')
    tag_filter = request.args.get('tag')
    search_query = request.args.get('q')
    
    query = News.query
    
    if status_filter:
        query = query.filter(News.status == status_filter)
    
    if category_filter:
        query = query.filter(News.category_id == category_filter)
    
    if tag_filter:
        tag = Tag.query.get(tag_filter)
        if tag:
            query = query.filter(News.tags_rel.contains(tag))
    
    if search_query:
        query = query.filter(News.title.ilike(f'%{search_query}%') | News.content.ilike(f'%{search_query}%'))
    
    news_pagination = query.order_by(News.publication_date.desc()).paginate(page=page, per_page=per_page)
    
    categories = Category.query.all()
    tags = Tag.query.all()

    # Obter categorias únicas para o filtro
    unique_categories = [cat.name for cat in categories]

    return render_template('admin/news_list.html', 
                          articles=news_pagination,
                          news_pagination=news_pagination, 
                          categories=categories, 
                           unique_categories=unique_categories,
                          tags=tags,
                           status_filter=status_filter,
                          category_filter=category_filter,
                          tag_filter=tag_filter,
                          search_query=search_query)

@app.route('/admin/news/new', methods=['GET', 'POST'])
@login_required
def new_news_article():
    if request.method == 'POST':
        print(f"DEBUG: Content-Length do cabeçalho: {request.headers.get('Content-Length')}")
        print(f"DEBUG: request.content_length: {request.content_length}")
        title = request.form['title']
        content = request.form['content']
        author = request.form['author']
        category = request.form.get('category')
        tags = request.form.get('tags')
        meta_description = request.form.get('meta_description')
        status = request.form.get('status', 'draft')
        sources = request.form.get('sources')
        is_featured = 'is_featured' in request.form
        allow_comments = 'allow_comments' in request.form
        social_title = request.form.get('social_title')
        social_description = request.form.get('social_description')

        # Slug manual ou gerado automaticamente
        slug = request.form.get('slug')
        if not slug:
            slug = slugify(title)
        else:
            slug = slugify(slug)
            
        # Garantir que o slug seja único
        base_slug = slug
        counter = 1
        while News.query.filter_by(slug=slug).first():
            slug = f"{base_slug}-{counter}"
            counter += 1

        featured_image = None
        if 'featured_image' in request.files and request.files['featured_image'].filename != '':
            image_file = request.files['featured_image']
            if image_file.content_length > app.config['MAX_CONTENT_LENGTH']:
                flash('Imagem muito grande! Tamanho máximo é 2MB.', 'error')
                return redirect(request.url)
            if not allowed_file(image_file.filename, ALLOWED_IMAGE_EXTENSIONS):
                flash('Formato de imagem inválido. Apenas JPG, JPEG, PNG, WEBP são permitidos.', 'error')
                return redirect(request.url)
            featured_image = save_and_resize_image(image_file)

        # Processar galeria de imagens
        gallery_images = []
        if 'gallery_images' in request.files:
            gallery_files = request.files.getlist('gallery_images')
            for image_file in gallery_files:
                if image_file.filename != '':
                    if not allowed_file(image_file.filename, ALLOWED_IMAGE_EXTENSIONS):
                        continue
                    image_filename = save_and_resize_image(image_file)
                    if image_filename:
                        gallery_images.append(image_filename)
        
        gallery_images_str = ','.join(gallery_images) if gallery_images else None

        video_filename = None
        video_url = request.form.get('video_url')
        
        # Processar URL do vídeo
        if video_url:
            video_embed_url = get_embed_url(video_url)
            print(f"DEBUG: URL do vídeo original: {video_url}")
            print(f"DEBUG: URL do vídeo embed: {video_embed_url}")
        else:
            video_embed_url = None

        # Processar upload de vídeo
        if 'video_file' in request.files and request.files['video_file'].filename != '':
            video_file = request.files['video_file']
            if not allowed_file(video_file.filename, ALLOWED_VIDEO_EXTENSIONS):
                flash('Formato de vídeo inválido. Apenas MP4, MOV, AVI, WEBM são permitidos.', 'error')
                return redirect(request.url)
            
            # Processar o vídeo para padronização
            video_filename = process_video(video_file)
            
            # Se temos um vídeo de upload, ignoramos a URL de vídeo
            if video_filename and video_embed_url:
                video_embed_url = None

        publish_date = None
        if status == 'scheduled' and request.form.get('publish_date'):
            try:
                publish_date = datetime.strptime(request.form['publish_date'], '%Y-%m-%dT%H:%M')
            except ValueError:
                flash('Formato de data inválido. Usando data e hora atuais.', 'warning')
                publish_date = datetime.now()
        else:
            publish_date = datetime.now()

        try:
            new_article = News(
                title=title, 
                content=content, 
                author=author,
                publication_date=publish_date, 
                category=category, 
                tags=tags,
                slug=slug, 
                meta_description=meta_description, 
                featured_image=featured_image,
                status=status, 
                sources=sources,
                video_filename=video_filename, 
                video_embed_url=video_embed_url,
                video_url=video_url,
                gallery_images=gallery_images_str,
                is_featured=is_featured,
                allow_comments=allow_comments,
                social_title=social_title,
                social_description=social_description
            )

            db.session.add(new_article)
            db.session.commit()
            flash('Notícia criada com sucesso!', 'success')
            return redirect(url_for('news_list'))
        except Exception as e:
            db.session.rollback()
            flash(f'Erro ao criar notícia: {str(e)}', 'error')
            print(f"ERRO: {str(e)}")
            return redirect(request.url)
    
    return render_template('admin/news_form.html')

@app.route('/admin/news/edit/<int:article_id>', methods=['GET', 'POST'])
@login_required
def edit_news_article(article_id):
    article = News.query.get_or_404(article_id)
    if request.method == 'POST':
        try:
            print(f"DEBUG: Iniciando edição da notícia ID {article_id}")
            print(f"DEBUG: Dados do formulário: {request.form}")
            print(f"DEBUG: Arquivos enviados: {request.files}")
            
            article.title = request.form['title']
            article.content = request.form['content']
            article.author = request.form['author']
            article.category = request.form.get('category')
            article.tags = request.form.get('tags')
            article.meta_description = request.form.get('meta_description')
            article.status = request.form.get('status', 'draft')
            article.sources = request.form.get('sources')
            article.is_featured = 'is_featured' in request.form
            article.allow_comments = 'allow_comments' in request.form
            article.social_title = request.form.get('social_title')
            article.social_description = request.form.get('social_description')
            
            # Slug manual ou manter o existente
            new_slug = request.form.get('slug')
            if new_slug:
                new_slug = slugify(new_slug)
                if new_slug != article.slug:
                    base_slug = new_slug
            slug = base_slug
            counter = 1
            while News.query.filter_by(slug=slug).filter(News.id != article.id).first():
                slug = f"{base_slug}-{counter}"
                counter += 1
            article.slug = slug

            # Imagem destacada
            if 'featured_image' in request.files and request.files['featured_image'].filename != '':
                image_file = request.files['featured_image']
                if not allowed_file(image_file.filename, ALLOWED_IMAGE_EXTENSIONS):
                    flash('Formato de imagem inválido. Apenas JPG, JPEG, PNG, WEBP são permitidos.', 'error')
                    return redirect(request.url)
                
                if article.featured_image:
                    for size in ['thumb', 'medium', 'original']:
                        old_path = os.path.join(app.config['UPLOAD_FOLDER_IMAGES'], size, article.featured_image)
                        if os.path.exists(old_path):
                            try: os.remove(old_path) 
                            except OSError: pass

                article.featured_image = save_and_resize_image(image_file)
            elif 'remove_featured_image' in request.form:
                if article.featured_image:
                    for size in ['thumb', 'medium', 'original']:
                        old_path = os.path.join(app.config['UPLOAD_FOLDER_IMAGES'], size, article.featured_image)
                        if os.path.exists(old_path):
                            try: os.remove(old_path)
                            except OSError: pass
                    article.featured_image = None

            # Galeria de imagens
            new_gallery_images = []
            if article.gallery_images:
                current_images = article.gallery_images.split(',')
                # Verificar quais imagens devem ser removidas
                for i, image in enumerate(current_images):
                    if f'remove_gallery_image_{i}' not in request.form:
                        new_gallery_images.append(image)
                    else:
                        # Remover arquivo da imagem
                        for size in ['thumb', 'medium', 'original']:
                            old_path = os.path.join(app.config['UPLOAD_FOLDER_IMAGES'], size, image)
                            if os.path.exists(old_path):
                                try: os.remove(old_path)
                                except OSError: pass
            
            # Adicionar novas imagens à galeria
            if 'gallery_images' in request.files:
                gallery_files = request.files.getlist('gallery_images')
                for image_file in gallery_files:
                    if image_file.filename != '':
                        if not allowed_file(image_file.filename, ALLOWED_IMAGE_EXTENSIONS):
                            continue
                        image_filename = save_and_resize_image(image_file)
                        if image_filename:
                            new_gallery_images.append(image_filename)
            
            article.gallery_images = ','.join(new_gallery_images) if new_gallery_images else None

            # Processar URL do vídeo
            video_url = request.form.get('video_url')
            if video_url:
                article.video_url = video_url
                article.video_embed_url = get_embed_url(video_url)
                print(f"DEBUG: URL do vídeo original: {video_url}")
                print(f"DEBUG: URL do vídeo embed: {article.video_embed_url}")
            elif 'remove_video_url' in request.form:
                article.video_url = None
                article.video_embed_url = None

            # Processar upload de vídeo
            if 'video_file' in request.files and request.files['video_file'].filename != '':
                video_file = request.files['video_file']
                if not allowed_file(video_file.filename, ALLOWED_VIDEO_EXTENSIONS):
                    flash('Formato de vídeo inválido. Apenas MP4, MOV, AVI, WEBM são permitidos.', 'error')
                    return redirect(request.url)

                # Remover vídeo antigo se existir
                if article.video_filename:
                    # Verificar e remover arquivo processado
                    processed_path = os.path.join(app.config['UPLOAD_FOLDER_VIDEOS_PROCESSED'], article.video_filename)
                    if os.path.exists(processed_path):
                        try:
                            os.remove(processed_path)
                        except OSError:
                            pass
                    
                    # Verificar e remover arquivo original
                    original_path = os.path.join(app.config['UPLOAD_FOLDER_VIDEOS'], article.video_filename)
                    if os.path.exists(original_path):
                        try:
                            os.remove(original_path)
                        except OSError:
                            pass

                # Processar o novo vídeo
                article.video_filename = process_video(video_file)
                
                # Se temos um vídeo de upload, ignoramos a URL de vídeo
                if article.video_filename:
                    article.video_url = None
            article.video_embed_url = None
                
            elif 'remove_video_file' in request.form:
                if article.video_filename:
                    # Verificar e remover arquivo processado
                    processed_path = os.path.join(app.config['UPLOAD_FOLDER_VIDEOS_PROCESSED'], article.video_filename)
                    if os.path.exists(processed_path):
                        try:
                            os.remove(processed_path)
                        except OSError:
                            pass
                    
                    # Verificar e remover arquivo original
                    original_path = os.path.join(app.config['UPLOAD_FOLDER_VIDEOS'], article.video_filename)
                    if os.path.exists(original_path):
                        try:
                            os.remove(original_path)
                        except OSError:
                            pass
                        
                article.video_filename = None 

            # Data de publicação para artigos agendados
            if article.status == 'scheduled' and request.form.get('publish_date'):
                try:
                    article.publication_date = datetime.strptime(request.form['publish_date'], '%Y-%m-%dT%H:%M')
                except ValueError:
                    flash('Formato de data inválido. Mantendo data existente.', 'warning')

            print("DEBUG: Salvando alterações no banco de dados")
            db.session.commit()
            print("DEBUG: Alterações salvas com sucesso")
            flash('Notícia atualizada com sucesso!', 'success')
            return redirect(url_for('news_list'))
        except Exception as e:
            db.session.rollback()
            import traceback
            print(f"ERRO DETALHADO: {str(e)}")
            print(traceback.format_exc())
            flash(f'Erro ao atualizar notícia: {str(e)}', 'error')
            return redirect(request.url)
    
    return render_template('admin/news_form.html', article=article)

@app.route('/admin/news/delete/<int:article_id>', methods=['POST'])
@login_required
def delete_news_article(article_id):
    article = News.query.get_or_404(article_id)
    # Delete associated files
    if article.featured_image:
        for size in ['thumb', 'medium', 'original']:
            old_path = os.path.join(app.config['UPLOAD_FOLDER_IMAGES'], size, article.featured_image)
            if os.path.exists(old_path):
                try: os.remove(old_path)
                except OSError: pass

    if article.video_filename:
        try: os.remove(os.path.join(app.config['UPLOAD_FOLDER_VIDEOS'], article.video_filename))
        except OSError: pass
    
    db.session.delete(article)
    db.session.commit()
    flash('Notícia excluída com sucesso!', 'success')
    return redirect(url_for('admin_dashboard'))

@app.route('/login', methods=['GET', 'POST'])
def login():
    if current_user.is_authenticated:
        return redirect(url_for('admin_dashboard'))
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        user = User.query.filter_by(username=username).first()
        if user and user.check_password(password):
            login_user(user)
            flash('Login bem-sucedido!', 'success')
            return redirect(url_for('admin_dashboard'))
        else:
            flash('Login inválido. Verifique o nome de usuário e a senha.', 'danger')
    return render_template('admin/login.html')

@app.route('/logout')
@login_required
def logout():
    logout_user()
    flash('Você foi desconectado.', 'info')
    return redirect(url_for('index'))

@app.route('/admin/comments')
@login_required
def comments_list():
    page = request.args.get('page', 1, type=int)
    status_filter = request.args.get('status', '')
    search_query = request.args.get('search', '')

    query = Comment.query.order_by(Comment.publication_date.desc())

    if status_filter == 'approved':
        query = query.filter_by(approved=True)
    elif status_filter == 'pending':
        query = query.filter_by(approved=False)

    if search_query:
        query = query.filter(db.or_(
            Comment.author.ilike(f'%{search_query}%'),
            Comment.content.ilike(f'%{search_query}%')
        ))

    comments = query.paginate(page=page, per_page=10, error_out=False)
    
    # Contadores para estatísticas
    approved_count = Comment.query.filter_by(approved=True).count()
    pending_count = Comment.query.filter_by(approved=False).count()

    return render_template('admin/comments_list.html', 
                          comments=comments, 
                          status_filter=status_filter,
                          search_query=search_query,
                          approved_count=approved_count,
                          pending_count=pending_count)

@app.route('/admin/comment/approve/<int:comment_id>', methods=['POST'])
@login_required
def approve_comment(comment_id):
    comment = Comment.query.get_or_404(comment_id)
    comment.approved = True
    db.session.commit()
    flash('Comentário aprovado com sucesso!', 'success')
    return redirect(url_for('comments_list'))

@app.route('/admin/comment/delete/<int:comment_id>', methods=['POST'])
@login_required
def delete_comment(comment_id):
    comment = Comment.query.get_or_404(comment_id)
    db.session.delete(comment)
    db.session.commit()
    flash('Comentário excluído com sucesso!', 'success')
    return redirect(url_for('comments_list'))

@app.route('/admin/upload-image', methods=['POST'])
@login_required
def upload_image():
    print("Iniciando upload de imagem...")
    if 'file' not in request.files:
        print("Erro: Nenhum arquivo enviado")
        return jsonify({'error': 'Nenhum arquivo enviado'}), 400
    
    file = request.files['file']
    print(f"Nome do arquivo: {file.filename}")
    
    if file.filename == '':
        print("Erro: Nenhum arquivo selecionado")
        return jsonify({'error': 'Nenhum arquivo selecionado'}), 400
    
    if file and allowed_file(file.filename, ALLOWED_IMAGE_EXTENSIONS):
        try:
            # Gerar nome único para o arquivo
            filename = str(uuid.uuid4()) + '.' + file.filename.rsplit('.', 1)[1].lower()
            print(f"Nome do arquivo após processamento: {filename}")
            
            # Salvar e redimensionar a imagem
            filename = save_and_resize_image(file)
            if not filename:
                print("Erro: Falha ao salvar a imagem")
                return jsonify({'error': 'Falha ao salvar a imagem'}), 500
            
            # Retornar URL da imagem (usando a versão medium)
            image_url = url_for('static', filename=f'uploads/images/medium/{filename}')
            print(f"URL da imagem: {image_url}")
            return jsonify({'location': image_url})
            
        except Exception as e:
            print(f"Erro ao processar imagem: {str(e)}")
            return jsonify({'error': f'Erro ao processar imagem: {str(e)}'}), 500
    
    print("Erro: Tipo de arquivo não permitido")
    return jsonify({'error': 'Tipo de arquivo não permitido'}), 400

def get_embed_url(url):
    """Converte URLs do YouTube/Vimeo em URLs de embed."""
    if not url:
        return None
    
    try:
        url = url.strip()
        
        # YouTube - vários formatos possíveis
        if 'youtu.be/' in url:
            # Formato curto: youtu.be/VIDEO_ID
            video_id = url.split('youtu.be/')[1].split('?')[0].split('&')[0]
            return f'https://www.youtube.com/embed/{video_id}'
        elif 'youtube.com/watch' in url:
            # Formato padrão: youtube.com/watch?v=VIDEO_ID
            from urllib.parse import urlparse, parse_qs
            qs = parse_qs(urlparse(url).query)
            video_id = qs.get('v', [None])[0]
            if video_id:
                return f'https://www.youtube.com/embed/{video_id}'
        elif 'youtube.com/embed/' in url:
            # URL já está no formato de embed
            return url.split('?')[0]
        
        # Vimeo - vários formatos possíveis
        elif 'vimeo.com/' in url and not 'player.vimeo.com/video/' in url:
            # Formato padrão: vimeo.com/VIDEO_ID
            import re
            match = re.search(r'vimeo\.com\/(\d+)', url)
            if match:
                return f'https://player.vimeo.com/video/{match.group(1)}'
        elif 'player.vimeo.com/video/' in url:
            # URL já está no formato de embed
            return url.split('?')[0]
    except Exception as e:
        print(f"Erro ao processar URL de vídeo: {str(e)}")
    
    # Se não conseguir converter, retornar a URL original
    print(f"URL não reconhecida para embed: {url}")
    return url

@app.route('/admin/users')
@login_required
def users_list():
    # Verificar se o usuário atual é administrador
    if current_user.role != 'admin':
        flash('Acesso negado. Apenas administradores podem gerenciar usuários.', 'danger')
        return redirect(url_for('admin_dashboard'))
        
    page = request.args.get('page', 1, type=int)
    search_query = request.args.get('search', '')
    role_filter = request.args.get('role', '')
    status_filter = request.args.get('status', '')

    query = User.query.order_by(User.username.asc())

    if search_query:
        query = query.filter(db.or_(
            User.username.ilike(f'%{search_query}%'),
            User.email.ilike(f'%{search_query}%')
        ))
    if role_filter:
        query = query.filter_by(role=role_filter)
    if status_filter == 'active':
        query = query.filter_by(active=True)
    elif status_filter == 'inactive':
        query = query.filter_by(active=False)

    users = query.paginate(page=page, per_page=10, error_out=False)
    
    # Contadores para estatísticas
    admin_count = User.query.filter_by(role='admin').count()
    active_count = User.query.filter_by(active=True).count()

    return render_template('admin/users_list.html',
                           users=users,
                           search_query=search_query,
                           role_filter=role_filter,
                           status_filter=status_filter,
                           admin_count=admin_count,
                           active_count=active_count)

@app.route('/admin/users/new', methods=['GET', 'POST'])
@login_required
def new_user():
    # Verificar se o usuário atual é administrador
    if current_user.role != 'admin':
        flash('Acesso negado. Apenas administradores podem criar usuários.', 'danger')
        return redirect(url_for('admin_dashboard'))
        
    if request.method == 'POST':
        username = request.form['username']
        email = request.form['email']
        password = request.form['password']
        role = request.form.get('role', 'redator')
        active = 'active' in request.form  # Checkbox retorna True se marcado

        # Validações
        if not username or len(username) < 3:
            flash('Nome de usuário deve ter pelo menos 3 caracteres.', 'danger')
            return redirect(url_for('new_user'))
            
        if not password or len(password) < 6:
            flash('Senha deve ter pelo menos 6 caracteres.', 'danger')
            return redirect(url_for('new_user'))

        if User.query.filter_by(username=username).first():
            flash('Nome de usuário já existe.', 'danger')
            return redirect(url_for('new_user'))
            
        if email and User.query.filter_by(email=email).first():
            flash('Email já registrado.', 'danger')
            return redirect(url_for('new_user'))

        new_user = User(username=username, email=email, role=role, active=active)
        new_user.set_password(password)
        db.session.add(new_user)
        db.session.commit()
        flash('Usuário criado com sucesso!', 'success')
        return redirect(url_for('users_list'))
    return render_template('admin/user_form.html')

@app.route('/admin/users/edit/<int:user_id>', methods=['GET', 'POST'])
@login_required
def edit_user(user_id):
    # Verificar se o usuário atual é administrador
    if current_user.role != 'admin':
        flash('Acesso negado. Apenas administradores podem editar usuários.', 'danger')
        return redirect(url_for('admin_dashboard'))
        
    user = User.query.get_or_404(user_id)
    
    # Não permitir editar o próprio usuário admin através desta rota
    if user.id == current_user.id:
        flash('Para editar seu próprio perfil, use a opção "Meu Perfil".', 'warning')
        return redirect(url_for('profile'))
        
    if request.method == 'POST':
        email = request.form['email']
        role = request.form.get('role', 'redator')
        active = 'active' in request.form
        
        # Verificar se o email já existe para outro usuário
        if email and email != user.email:
            existing_user = User.query.filter_by(email=email).first()
            if existing_user and existing_user.id != user.id:
                flash('Email já está sendo usado por outro usuário.', 'danger')
                return render_template('admin/user_form.html', user=user)
        
        user.email = email
        user.role = role
        user.active = active

        db.session.commit()
        flash('Usuário atualizado com sucesso!', 'success')
        return redirect(url_for('users_list'))
    return render_template('admin/user_form.html', user=user)

@app.route('/admin/users/toggle_active/<int:user_id>', methods=['POST'])
@login_required
def toggle_user_active(user_id):
    # Verificar se o usuário atual é administrador
    if current_user.role != 'admin':
        flash('Acesso negado. Apenas administradores podem ativar/inativar usuários.', 'danger')
        return redirect(url_for('admin_dashboard'))
        
    user = User.query.get_or_404(user_id)
    
    # Não permitir inativar o próprio usuário
    if user.id == current_user.id:
        flash('Você não pode inativar seu próprio usuário.', 'danger')
        return redirect(url_for('users_list'))
        
    user.active = not user.active
    db.session.commit()
    flash(f'Usuário {user.username} {"ativado" if user.active else "inativado"} com sucesso!', 'success')
    return redirect(url_for('users_list'))

@app.route('/admin/users/change_role/<int:user_id>', methods=['POST'])
@login_required
def change_user_role(user_id):
    # Verificar se o usuário atual é administrador
    if current_user.role != 'admin':
        flash('Acesso negado. Apenas administradores podem alterar papéis de usuários.', 'danger')
        return redirect(url_for('admin_dashboard'))
        
    user = User.query.get_or_404(user_id)
    
    # Não permitir alterar o papel do próprio usuário
    if user.id == current_user.id:
        flash('Você não pode alterar seu próprio papel.', 'danger')
        return redirect(url_for('users_list'))
        
    new_role = request.form.get('new_role')
    
    # Validação dos papéis permitidos
    allowed_roles = ['admin', 'editor', 'redator', 'revisor']
    if new_role and new_role in allowed_roles:
        user.role = new_role
        db.session.commit()
        flash(f'Papel do usuário {user.username} alterado para {new_role} com sucesso!', 'success')
    else:
        flash('Papel inválido ou não fornecido.', 'danger')
    return redirect(url_for('users_list'))

@app.route('/admin/users/reset_password/<int:user_id>', methods=['POST'])
@login_required
def reset_user_password(user_id):
    # Verificar se o usuário atual é administrador
    if current_user.role != 'admin':
        flash('Acesso negado. Apenas administradores podem redefinir senhas.', 'danger')
        return redirect(url_for('admin_dashboard'))
        
    user = User.query.get_or_404(user_id)
    new_password = request.form.get('new_password')
    
    if not new_password or len(new_password) < 6:
        flash('A nova senha deve ter pelo menos 6 caracteres.', 'danger')
        return redirect(url_for('users_list'))
    
    user.set_password(new_password)
    db.session.commit()
    flash(f'Senha do usuário {user.username} redefinida com sucesso!', 'success')
    return redirect(url_for('users_list'))

@app.route('/admin/profile', methods=['GET', 'POST'])
@login_required
def profile():
    user = current_user
    
    # Calcular estatísticas do usuário
    user_news_count = News.query.filter_by(author_id=user.id).count()
    
    # Calcular idade da conta em dias
    if user.created_at:
        today = datetime.now()
        account_age = (today - user.created_at).days
    else:
        account_age = "N/A"
    
    if request.method == 'POST':
        # Verificar qual formulário foi enviado
        if 'update_profile' in request.form:
            # Atualizar informações do perfil
            email = request.form['email']
            
            # Verificar se o email já existe para outro usuário
            if email and email != user.email:
                existing_user = User.query.filter_by(email=email).first()
                if existing_user and existing_user.id != user.id:
                    flash('Email já está sendo usado por outro usuário.', 'danger')
                    return render_template('admin/profile.html', 
                                          user=user, 
                                          user_news_count=user_news_count,
                                          account_age=account_age)
            
            user.email = email
            db.session.commit()
            flash('Perfil atualizado com sucesso!', 'success')
            
        elif 'update_password' in request.form:
            # Atualizar senha
            current_password = request.form.get('current_password')
            new_password = request.form.get('new_password')
            confirm_password = request.form.get('confirm_password')
            
            # Validar senha atual
            if not current_password or not user.check_password(current_password):
                flash('Senha atual incorreta.', 'danger')
                return render_template('admin/profile.html', 
                                      user=user, 
                                      user_news_count=user_news_count,
                                      account_age=account_age)
            
            # Validar nova senha
            if not new_password:
                flash('Nova senha não pode estar em branco.', 'danger')
                return render_template('admin/profile.html', 
                                      user=user, 
                                      user_news_count=user_news_count,
                                      account_age=account_age)
                
            if new_password != confirm_password:
                flash('Nova senha e confirmação não coincidem.', 'danger')
                return render_template('admin/profile.html', 
                                      user=user, 
                                      user_news_count=user_news_count,
                                      account_age=account_age)
                
            if len(new_password) < 6:
                flash('Nova senha deve ter pelo menos 6 caracteres.', 'danger')
                return render_template('admin/profile.html', 
                                      user=user, 
                                      user_news_count=user_news_count,
                                      account_age=account_age)
                
            user.set_password(new_password)
            db.session.commit()
            flash('Senha alterada com sucesso!', 'success')
        
        return redirect(url_for('profile'))
        
    return render_template('admin/profile.html', 
                          user=user,
                          user_news_count=user_news_count,
                          account_age=account_age)

@app.route('/admin/news/preview/<int:article_id>')
@login_required
def preview_news_article(article_id):
    article = News.query.get_or_404(article_id)
    
    # Converter a lista de imagens da galeria para JSON se existir
    gallery_images_json = None
    if article.gallery_images:
        gallery_images = article.gallery_images.split(',')
        gallery_images_json = json.dumps([url_for('static', filename=f'uploads/images/medium/{img}') for img in gallery_images])
    
    # Renderizar o template de detalhes da notícia, mas com um banner indicando que é uma prévia
    return render_template('news/news_detail.html', 
                          article=article, 
                          current_year=datetime.now().year,
                          gallery_images_json=gallery_images_json,
                          is_preview=True)

@app.route('/admin/scheduled')
@login_required
def scheduled_news():
    # Buscar notícias agendadas ordenadas por data de publicação
    scheduled_articles = News.query.filter_by(status='scheduled').order_by(News.publication_date.asc()).all()
    
    # Obter data e hora atual para comparação
    now = datetime.now()
    
    # Categorizar notícias por período de publicação
    today = []
    tomorrow = []
    this_week = []
    later = []
    
    for article in scheduled_articles:
        # Calcular diferença de tempo
        time_diff = article.publication_date - now
        days_diff = time_diff.days
        
        # Categorizar com base na diferença de dias
        if days_diff < 0:
            # Notícias com data no passado (possivelmente não processadas ainda)
            today.append(article)
        elif days_diff == 0:
            # Notícias para hoje
            today.append(article)
        elif days_diff == 1:
            # Notícias para amanhã
            tomorrow.append(article)
        elif days_diff < 7:
            # Notícias para esta semana
            this_week.append(article)
        else:
            # Notícias para depois
            later.append(article)
    
    return render_template('admin/scheduled_news.html',
                          scheduled_articles=scheduled_articles,
                          today=today,
                          tomorrow=tomorrow,
                          this_week=this_week,
                          later=later,
                          now=now)

def check_scheduled_news():
    """
    Verifica e publica notícias que foram agendadas para publicação.
    Esta função será executada em uma thread separada.
    """
    print("Iniciando verificador de notícias agendadas...")
    
    while True:
        try:
            with app.app_context():
                # Buscar notícias agendadas cuja data de publicação já passou
                now = datetime.now()
                scheduled_news = News.query.filter(
                    News.status == 'scheduled',
                    News.publication_date <= now
                ).all()
                
                if scheduled_news:
                    print(f"Encontradas {len(scheduled_news)} notícias para publicação automática.")
                    
                    for article in scheduled_news:
                        article.status = 'published'
                        print(f"Publicando notícia: {article.title} (ID: {article.id})")
                    
                    db.session.commit()
                    print("Notícias publicadas com sucesso.")
                
        except Exception as e:
            print(f"Erro ao verificar notícias agendadas: {str(e)}")
        
        # Verificar a cada 60 segundos
        time.sleep(60)

# Iniciar a thread de verificação de notícias agendadas
scheduler_thread = None

# Iniciar o agendador quando o aplicativo iniciar
@app.before_request
def start_scheduler_if_needed():
    global scheduler_thread
    if not scheduler_thread or not scheduler_thread.is_alive():
        scheduler_thread = threading.Thread(target=check_scheduled_news)
        scheduler_thread.daemon = True  # A thread será encerrada quando o programa principal terminar
        scheduler_thread.start()
        print("Agendador de publicações iniciado.")

# Rota para adicionar categoria via AJAX
@app.route('/admin/categories/add', methods=['POST'])
@login_required
def add_category():
    if current_user.role not in ['admin', 'editor']:
        return jsonify({'success': False, 'error': 'Permissão negada'}), 403
    
    data = request.json
    name = data.get('name')
    description = data.get('description')
    parent_id = data.get('parent_id')
    
    if not name:
        return jsonify({'success': False, 'error': 'Nome da categoria é obrigatório'}), 400
    
    # Verificar se já existe uma categoria com o mesmo nome
    existing_category = Category.query.filter_by(name=name).first()
    if existing_category:
        return jsonify({'success': False, 'error': 'Já existe uma categoria com este nome'}), 400
    
    # Criar nova categoria
    new_category = Category(name=name, description=description)
    if parent_id:
        new_category.parent_id = parent_id
    
    try:
        db.session.add(new_category)
        db.session.commit()
        return jsonify({
            'success': True, 
            'category': {
                'id': new_category.id, 
                'name': new_category.name, 
                'slug': new_category.slug
            }
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

# Rota para listar categorias
@app.route('/admin/categories')
@login_required
def categories_list():
    if current_user.role not in ['admin', 'editor']:
        flash('Permissão negada', 'danger')
        return redirect(url_for('admin_dashboard'))
    
    categories = Category.query.all()
    return render_template('admin/categories_list.html', categories=categories)

# Rota para editar categoria
@app.route('/admin/categories/<int:id>/edit', methods=['GET', 'POST'])
@login_required
def edit_category(id):
    if current_user.role not in ['admin', 'editor']:
        flash('Permissão negada', 'danger')
        return redirect(url_for('admin_dashboard'))
    
    category = Category.query.get_or_404(id)
    
    if request.method == 'POST':
        name = request.form.get('name')
        description = request.form.get('description')
        parent_id = request.form.get('parent_id')
        
        if not name:
            flash('Nome da categoria é obrigatório', 'danger')
            return redirect(url_for('edit_category', id=id))
        
        # Verificar se já existe outra categoria com o mesmo nome
        existing_category = Category.query.filter(Category.name == name, Category.id != id).first()
        if existing_category:
            flash('Já existe uma categoria com este nome', 'danger')
            return redirect(url_for('edit_category', id=id))
        
        category.name = name
        category.description = description
        
        # Evitar ciclos em categorias pai/filho
        if parent_id and int(parent_id) != 0:
            if int(parent_id) == category.id:
                flash('Uma categoria não pode ser pai dela mesma', 'danger')
                return redirect(url_for('edit_category', id=id))
            category.parent_id = parent_id
        else:
            category.parent_id = None
        
        try:
            db.session.commit()
            flash('Categoria atualizada com sucesso', 'success')
            return redirect(url_for('categories_list'))
        except Exception as e:
            db.session.rollback()
            flash(f'Erro ao atualizar categoria: {str(e)}', 'danger')
    
    categories = Category.query.filter(Category.id != id).all()
    return render_template('admin/category_form.html', category=category, categories=categories)

# Rota para excluir categoria
@app.route('/admin/categories/<int:id>/delete', methods=['POST'])
@login_required
def delete_category(id):
    if current_user.role not in ['admin', 'editor']:
        flash('Permissão negada', 'danger')
        return redirect(url_for('admin_dashboard'))
    
    category = Category.query.get_or_404(id)
    
    # Verificar se há notícias usando esta categoria
    news_count = News.query.filter_by(category_id=id).count()
    if news_count > 0:
        flash(f'Não é possível excluir esta categoria. Existem {news_count} notícias vinculadas a ela.', 'danger')
        return redirect(url_for('categories_list'))
    
    # Verificar se há subcategorias
    subcategories = Category.query.filter_by(parent_id=id).all()
    if subcategories:
        flash('Não é possível excluir esta categoria. Existem subcategorias vinculadas a ela.', 'danger')
        return redirect(url_for('categories_list'))
    
    try:
        db.session.delete(category)
        db.session.commit()
        flash('Categoria excluída com sucesso', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Erro ao excluir categoria: {str(e)}', 'danger')
    
    return redirect(url_for('categories_list'))

# Rota para listar tags
@app.route('/admin/tags')
@login_required
def tags_list():
    if current_user.role not in ['admin', 'editor']:
        flash('Permissão negada', 'danger')
        return redirect(url_for('admin_dashboard'))
    
    tags = Tag.query.all()
    return render_template('admin/tags_list.html', tags=tags)

# Rota para editar tag
@app.route('/admin/tags/<int:id>/edit', methods=['GET', 'POST'])
@login_required
def edit_tag(id):
    if current_user.role not in ['admin', 'editor']:
        flash('Permissão negada', 'danger')
        return redirect(url_for('admin_dashboard'))
    
    tag = Tag.query.get_or_404(id)
    
    if request.method == 'POST':
        name = request.form.get('name')
        
        if not name:
            flash('Nome da tag é obrigatório', 'danger')
            return redirect(url_for('edit_tag', id=id))
        
        # Verificar se já existe outra tag com o mesmo nome
        existing_tag = Tag.query.filter(Tag.name == name, Tag.id != id).first()
        if existing_tag:
            flash('Já existe uma tag com este nome', 'danger')
            return redirect(url_for('edit_tag', id=id))
        
        tag.name = name
        
        try:
            db.session.commit()
            flash('Tag atualizada com sucesso', 'success')
            return redirect(url_for('tags_list'))
        except Exception as e:
            db.session.rollback()
            flash(f'Erro ao atualizar tag: {str(e)}', 'danger')
    
    return render_template('admin/tag_form.html', tag=tag)

# Rota para excluir tag
@app.route('/admin/tags/<int:id>/delete', methods=['POST'])
@login_required
def delete_tag(id):
    if current_user.role not in ['admin', 'editor']:
        flash('Permissão negada', 'danger')
        return redirect(url_for('admin_dashboard'))
    
    tag = Tag.query.get_or_404(id)
    
    # Verificar se há notícias usando esta tag
    news_count = len(tag.news_articles)
    if news_count > 0:
        flash(f'Esta tag está sendo usada em {news_count} notícias. Deseja realmente excluí-la?', 'warning')
        # Aqui poderia ter uma confirmação adicional, mas vamos prosseguir com a exclusão
    
    try:
        db.session.delete(tag)
        db.session.commit()
        flash('Tag excluída com sucesso', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Erro ao excluir tag: {str(e)}', 'danger')
    
    return redirect(url_for('tags_list'))

# Rota para adicionar tag via AJAX
@app.route('/admin/tags/add', methods=['POST'])
@login_required
def add_tag():
    if current_user.role not in ['admin', 'editor']:
        return jsonify({'success': False, 'error': 'Permissão negada'}), 403
    
    if request.is_json:
        data = request.json
        name = data.get('name')
    else:
        name = request.form.get('name')
    
    if not name:
        if request.is_json:
            return jsonify({'success': False, 'error': 'Nome da tag é obrigatório'}), 400
        flash('Nome da tag é obrigatório', 'danger')
        return redirect(url_for('tags_list'))
    
    # Verificar se já existe uma tag com o mesmo nome
    existing_tag = Tag.query.filter_by(name=name).first()
    if existing_tag:
        if request.is_json:
            return jsonify({'success': False, 'error': 'Já existe uma tag com este nome'}), 400
        flash('Já existe uma tag com este nome', 'danger')
        return redirect(url_for('tags_list'))
    
    # Criar nova tag
    new_tag = Tag(name=name)
    
    try:
        db.session.add(new_tag)
        db.session.commit()
        
        if request.is_json:
            return jsonify({
                'success': True, 
                'tag': {
                    'id': new_tag.id, 
                    'name': new_tag.name, 
                    'slug': new_tag.slug
                }
            })
        
        flash('Tag criada com sucesso', 'success')
        return redirect(url_for('tags_list'))
    except Exception as e:
        db.session.rollback()
        if request.is_json:
            return jsonify({'success': False, 'error': str(e)}), 500
        flash(f'Erro ao criar tag: {str(e)}', 'danger')
        return redirect(url_for('tags_list'))

# Modificar a rota de criação/edição de notícias para usar categorias e tags
@app.route('/admin/news/create', methods=['GET', 'POST'])
@app.route('/admin/news/<int:id>/edit', methods=['GET', 'POST'])
@login_required
def create_edit_news(id=None):
    if current_user.role not in ['admin', 'editor', 'redator']:
        flash('Permissão negada', 'danger')
        return redirect(url_for('admin_dashboard'))
    
    article = None
    if id:
        article = News.query.get_or_404(id)
    
    if request.method == 'POST':
        title = request.form.get('title')
        content = request.form.get('content')
        author = request.form.get('author')
        status = request.form.get('status')
        category_id = request.form.get('category_id')
        tags_input = request.form.get('tags_input')
        meta_description = request.form.get('meta_description')
        sources = request.form.get('sources')
        is_featured = 'is_featured' in request.form
        allow_comments = 'allow_comments' in request.form
        social_title = request.form.get('social_title')
        social_description = request.form.get('social_description')
        publication_date_str = request.form.get('publication_date')
        
        # Processar data de publicação
        publication_date = None
        if publication_date_str:
            try:
                publication_date = datetime.strptime(publication_date_str, '%Y-%m-%dT%H:%M')
            except ValueError:
                flash('Formato de data inválido', 'danger')
                return redirect(request.url)
        else:
            publication_date = datetime.now()
        
        if not article:
            article = News(
                title=title,
                content=content,
                author=author,
                author_id=current_user.id,
                status=status,
                publication_date=publication_date,
                meta_description=meta_description,
                sources=sources,
                is_featured=is_featured,
                allow_comments=allow_comments,
                social_title=social_title,
                social_description=social_description
            )
            db.session.add(article)
            flash_message = 'Notícia criada com sucesso!'
        else:
            article.title = title
            article.content = content
            article.author = author
            article.status = status
            article.publication_date = publication_date
            article.meta_description = meta_description
            article.sources = sources
            article.is_featured = is_featured
            article.allow_comments = allow_comments
            article.social_title = social_title
            article.social_description = social_description
            flash_message = 'Notícia atualizada com sucesso!'
        
        # Processar categoria
        if category_id:
            article.category_id = category_id
            # Manter o campo de string de categoria para compatibilidade
            category = Category.query.get(category_id)
            if category:
                article.category = category.name
        
        # Processar tags
        if tags_input:
            # Limpar as tags existentes
            article.tags_rel.clear()
            
            # Adicionar novas tags
            tag_names = [tag.strip() for tag in tags_input.split(',') if tag.strip()]
            for tag_name in tag_names:
                tag = Tag.query.filter_by(name=tag_name).first()
                if not tag:
                    tag = Tag(name=tag_name)
                    db.session.add(tag)
                article.tags_rel.append(tag)
            
            # Atualizar o campo de string de tags para compatibilidade
            article.tags = tags_input
        
        # Processar imagem destacada
        featured_image = request.files.get('featured_image')
        if featured_image and featured_image.filename:
            filename = secure_filename(featured_image.filename)
            unique_filename = str(uuid.uuid4()) + os.path.splitext(filename)[1]
            save_path = os.path.join(app.config['UPLOAD_FOLDER'], 'images', 'original', unique_filename)
            featured_image.save(save_path)
            article.featured_image = '/static/uploads/images/original/' + unique_filename
        
        # Processar vídeo
        video_file = request.files.get('video_filename')
        if video_file and video_file.filename:
            video_filename = secure_filename(video_file.filename)
            unique_video_filename = str(uuid.uuid4()) + os.path.splitext(video_filename)[1]
            video_save_path = os.path.join(app.config['UPLOAD_FOLDER'], 'videos', unique_video_filename)
            video_file.save(video_save_path)
            article.video_filename = '/static/uploads/videos/' + unique_video_filename
        
        # Processar URLs de vídeo
        article.video_url = request.form.get('video_url')
        article.video_embed_url = request.form.get('video_embed_url')
        
        try:
            db.session.commit()
            flash(flash_message, 'success')
            return redirect(url_for('news_list'))
        except Exception as e:
            db.session.rollback()
            flash(f'Erro ao salvar notícia: {str(e)}', 'danger')
            return redirect(request.url)
    
    categories = Category.query.all()
    popular_tags = Tag.query.order_by(db.func.random()).limit(10).all()  # Exibir 10 tags aleatórias como sugestão
    
    return render_template('admin/news_form.html', article=article, categories=categories, popular_tags=popular_tags)

# Rota para busca avançada
@app.route('/busca', methods=['GET'])
def advanced_search():
    # Parâmetros de busca
    query = request.args.get('q', '')
    category_id = request.args.get('category', type=int)
    tag_id = request.args.get('tag', type=int)
    date_from = request.args.get('date_from', '')
    date_to = request.args.get('date_to', '')
    author = request.args.get('author', '')
    page = request.args.get('page', 1, type=int)
    per_page = 10
    
    # Iniciar a consulta base
    search_query = News.query.filter_by(status='published')
    
    # Aplicar filtros
    if query:
        search_query = search_query.filter(
            db.or_(
                News.title.ilike(f'%{query}%'),
                News.content.ilike(f'%{query}%')
            )
        )
    
    if category_id:
        search_query = search_query.filter(News.category_id == category_id)
    
    if tag_id:
        tag = Tag.query.get(tag_id)
        if tag:
            search_query = search_query.filter(News.tags_rel.contains(tag))
    
    if date_from:
        try:
            date_from_obj = datetime.strptime(date_from, '%Y-%m-%d')
            search_query = search_query.filter(News.publication_date >= date_from_obj)
        except ValueError:
            pass
    
    if date_to:
        try:
            date_to_obj = datetime.strptime(date_to, '%Y-%m-%d')
            # Adicionar um dia para incluir todo o dia final
            date_to_obj = date_to_obj + timedelta(days=1)
            search_query = search_query.filter(News.publication_date <= date_to_obj)
        except ValueError:
            pass
    
    if author:
        search_query = search_query.filter(News.author.ilike(f'%{author}%'))
    
    # Ordenar e paginar resultados
    search_results = search_query.order_by(News.publication_date.desc()).paginate(page=page, per_page=per_page)
    
    # Obter todas as categorias e tags para os filtros
    categories = Category.query.all()
    popular_tags = Tag.query.order_by(db.func.random()).limit(30).all()
    
    return render_template(
        'news/search.html',
        search_results=search_results,
        query=query,
        category_id=category_id,
        tag_id=tag_id,
        date_from=date_from,
        date_to=date_to,
        author=author,
        categories=categories,
        popular_tags=popular_tags
    )

if __name__ == '__main__':
    with app.app_context():
        db.create_all() # Criar as tabelas do banco de dados se elas não existirem

        # Verificar se o usuário admin já existe, se não, criá-lo
        admin = User.query.filter_by(username='admin').first()
        if not admin:
            hashed_password = bcrypt.generate_password_hash('admin123').decode('utf-8')
            admin = User(
                username='admin',
                email='admin@example.com',
                password_hash=hashed_password,
                role='admin'
            )
            db.session.add(admin)
            db.session.commit()
            print("Usuário admin criado com sucesso!")
            print("Username: admin")
            print("Senha: admin123")
    app.run(debug=True) 